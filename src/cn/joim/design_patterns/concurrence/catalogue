1. 信号模式
这一模式介绍如何实现某一任务向另一任务通告某一事件的情形。
实现这种模式最简单的方式是采用信号量或者互斥，使用Java语言的ReentranceLock类或者Semaphore类即可。

2. 会合模式
它是信号模式的推广。第一个任务将等待第二个任务的某一事件，第二个任务又要等待第一个任务的某一事件。

3. 互斥模式
互斥模式可以用来设置临界段，确保操作可以相互排斥。一次只有一个任务可以执行由互斥机制保护的代码片段。在Java中，可以使用synchronized关键字、ReentranceLock或者Semaphore类来实现一个临界段。

4. 多元复用模式
在这种情形下，规定数目的任务可以同时执行临界段。

5.栅栏模式
栅栏模式实现了在某一共同点上实现任务同步的情形。每个任务都必须等到所有任务都达到同步点后才能继续执行。Java并发API提供了CyclicBarrier类。

6. 双重检查锁定模式
当你获得某个锁之后要检查某项条件时，这种模式可以为解决该问题提供方案。对象的延迟初始化就是这种青款的例子。

7. 读-写锁模式
当你用锁来保护对某个共享变量的访问时，只有一个任务可以访问该变量，这和你将要对该变量实施的操作是互相独立的。有时，你的变量需要修改的次数很少，却需要读取很多次。这种情况下，锁的性能就比较差了，因为所有读操作都可以并发进行而不会带来任何问题。为解决这样的问题，出现了读-写模式。这种模式定义了一种特殊的锁，它含有两个内部锁：一个用于读操作，而另一个用于写操作。该锁的特点如下所示：
- 如果一个任务正在执行读操作而另一个任务想要进行另一读操作，那么另一任务可以进行该操作；
- 如果一个任务正在进行读操作而另一任务想要进行写操作，那么另一任务会被阻塞，直到所有读操作完成为止；
- 如果一个任务正在执行写操作而另一任务想要执行另一操作（读或写），那么另一任务将被阻塞，直到写入方完成操作为止。

8. 线程池模式
这种模式试图减少执行每个任务而创建线程所引入的开销。该模式由一个线程集合和一个待执行的任务队列构成。线程集合通常具有固定的大小。当一个线程完成了某个任务的执行时，它本身并不会结束执行，它要寻找队列中的另一个任务。如果存在另一个任务，那么它将继续执行该任务，否则会一直等待（知道某个超时状态发生）。Java并发API包含一些实现ExecutorService接口的类，该接口内部采用了一个线程池。

9. 线程局部模式
这种模式定义了如何使用局部从属于任务的全局变量或静态变量。当某个类中有一个静态属性时，那么该类的所有对象都会访问该属性的统一存在。如果使用了线程局部存储，则每个线程都会访问该变量的一个不同实例。Java并发API包含了ThreadLocal类，该类实现了这种设计模式。
